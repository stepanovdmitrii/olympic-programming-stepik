#include <iostream>
#include <vector>
#include <algorithm>

/*
Фрекен Бок засыпает
Иногда после обеда Фрекен Бок мучает бессонница. Тогда, чтобы заснуть, она закрывает глаза и представляет овечек. Они пронумерованы от 1 до N ≤ 105 и бегают по кругу так, что перед первой бегает овечка с номером N, а перед любой другой — овечка с номером на единицу меньшим. Для наглядности она представляет четных овечек нежно-розовыми, а нечетных — небесно-голубыми. Иногда в ее сон заглядывает расшалившийся Карлсон и пытается утащить какую-нибудь овечку (назовем ее Лямбда). Если в этот момент обе соседки Лямбды (перед ней и после нее) разного цвета, Карлсону не удается его проделка, и Лямбда остается на месте. Если же ее соседки одного цвета, то Карлсон нахально забирает Лямбду из сна, а овечки смыкаются и продолжают бегать по кругу как ни в чем ни бывало (при этом они не меняют свой номер и цвет). Через некоторое время Фрекен Бок пытается выяснить, сколько всего овечек у нее осталось и засыпает. А Вопрос остается.

Входные данные:
В первой строке два натуральных числа N и K (3 ≤ N ≤ 50000, 1 ≤ K ≤ N−2). Во второй строке через пробел K чисел, каждое из интервала от 1 до N — номера овечек в том порядке, в котором их пытается утащить Карлсон. Если овечки с указанным номером к моменту, когда за ней приходит Карлсон уже нет, ничего не происходит.

Выходные данные:
Одно число — ответ на вопрос.

Sample Input:

13 11
1 2 1 13 2 6 12 3 13 5 3

Sample Output:

8
*/

struct node
{
    size_t number;
    node *next;
    node *prev;
};

int main()
{
    size_t count;
    std::cin >> count;

    std::vector<node *> queue(count, nullptr);
    node *head = nullptr;

    for (size_t idx = 0; idx < count; ++idx)
    {
        node *n = new node();
        n->number = idx + 1;
        queue[idx] = n;
        if (idx == 0)
        {
            head = n;
            continue;
        }

        node *previous = queue[idx - 1];
        previous->next = n;
        n->prev = previous;
    }

    if (count > 1)
    {
        queue[count - 1]->next = head;
        head->prev = queue[count - 1];
    }

    size_t left = count;
    size_t k;
    std::cin >> k;
    for (size_t i = 0; i < k; ++i)
    {
        size_t idx;
        std::cin >> idx;
        idx--;
        if (queue[idx] == nullptr)
        {
            continue;
        }
        node *n = queue[idx];
        if (n->prev->number % 2 == n->next->number % 2)
        {
            queue[idx] = nullptr;
            n->prev->next = n->next;
            n->next->prev = n->prev;
            delete n;
            left--;
        }
    }
    std::cout << left;
    return 0;
}